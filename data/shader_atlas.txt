//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
singlePass basic.vs singlePass.fs
multiPass basic.vs multiPass.fs
noLights basic.vs noLights.fs
gbuffers basic.vs gbuffers.fs
deferred quad.vs deferred.fs
deferred_opti basic.vs deferred.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
ssao quad.vs ssaoFrag.fs
ssaoBlur quad.vs ssaoblur.fs
tonemapper quad.vs tonemapping.fs
probe basic.vs probe.fs
irradiance quad.vs irradiance.fs
skybox basic.vs skybox.fs
reflectionProbe basic.vs reflectionProbe.fs
volumetric quad.vs volumetric.fs
decal basic.vs decal.fs
blur quad.vs blur.fs
depthOfField quad.vs depthOfField.fs
mix quad.vs mix.fs
brightFilter quad.vs brightFilter.fs


\constants
#define PI 3.141592654





\sphericalHarmonics
#include "constants"
const float CosineA0 = PI;
const float CosineA1 = (2.0 * PI) / 3.0;
const float CosineA2 = PI * 0.25;

struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; }; //to store colors

void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
	// Band 0
	sh.c[0] = 0.282095 * CosineA0;
	// Band 1
	sh.c[1] = 0.488603 * dir.y * CosineA1; 
	sh.c[2] = 0.488603 * dir.z * CosineA1;
	sh.c[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradianceVec(in vec3 normal, in vec3 sh1[9])
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh1[i] * shCosine.c[i];

	return irradiance;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh.c[i] * shCosine.c[i];

	return irradiance;
}




\hdr

uniform bool useHDR;

vec3 degamma(vec3 c)
{
	return pow(c,vec3(2.2));
}

vec3 gamma(vec3 c)
{
	return pow(c,vec3(1.0/2.2));
}



\mapFunction
int map(int x, int in_min, int in_max, int out_min, int out_max){
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float mapFloat(float x, float in_min, float in_max, float out_min, float out_max){
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


\shadowAtlas
uniform vec3 shadowMapInfo[MAX_LIGHTS]; //vec3(x,y,size);
uniform sampler2D shadowAtlasTexture;

#include "mapFunction"



vec4 getColorFromAtlas(vec2 uv, int shadowMapIndex,sampler2D atlas){
	vec3 cellInfo= shadowMapInfo[shadowMapIndex];
	float x_displ= mapFloat(uv.x,0,1,0,cellInfo.z);
	float y_displ= mapFloat(uv.y,0,1,0,cellInfo.z);
	
	vec2 pos= vec2(cellInfo.x+x_displ,cellInfo.y+y_displ);
	return texture(atlas,pos);
}

\ssaoCalc
uniform bool u_use_SSAO;
uniform sampler2D u_SSAO_texture;


float getFactor(float factor, vec2 uv){
	if (!u_use_SSAO)
		return factor;
	else
		return texture(u_SSAO_texture,uv).x;

}


\normals

mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}

// assume N, the interpolated vertex normal and 
// WP the world position
//vec3 normal_pixel = texture2D( normalmap, uv ).xyz; 
vec3 perturbNormal(vec3 N, vec3 WP, vec2 uv, vec3 normal_pixel)
{
	normal_pixel = normal_pixel * 255./127. - 128./127.;
	mat3 TBN = cotangent_frame(N, WP, uv);
	return normalize(TBN * normal_pixel);
}



\shadows
#include "shadowAtlas"

float getShadowAttenuation(vec3 pos, mat4 viewProjection, float bias, sampler2D shadowMap, bool isDirectional, bool useShadowAtlas, int shadowIndex, bool ignoreExtremes)
{
	//project our 3D position to the shadowmap
	vec4 proj_pos = viewProjection * vec4(pos,1.0);

	//from homogeneus space to clip space
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;

	//from clip space to uv space
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
	
	

	//get point depth [-1 .. +1] in non-linear space
	float real_depth = (proj_pos.z - bias) / proj_pos.w;

	
	//normalize from [-1..+1] to [0..+1] still non-linear
	real_depth = real_depth * 0.5 + 0.5;
	if (isDirectional)
		if((real_depth<0.0||real_depth>1.0)||(shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0))
			return 1.0;

	//read depth from depth buffer in [0..+1] non-linear
	vec4 texture_depth= (useShadowAtlas==true)? getColorFromAtlas(shadow_uv,shadowIndex,shadowMap):texture( shadowMap, shadow_uv);
	float shadow_depth = texture_depth.x;
	//float shadow_depth = texture( shadowMap, shadow_uv).x;

	//compute final shadow factor by comparing
	float shadow_factor = 1.0;

	//we can compare them, even if they are not linear
	if(!ignoreExtremes)
		if( shadow_depth < real_depth &&  (real_depth>0.0&& real_depth<1.0) )
			shadow_factor = 0.0;
		

	
	
	//We do this to avoid directional light casting shadows on stuff that are out the shadowmap range
		
	return shadow_factor;

}

\pointdata

struct pointData{
	vec3 N; //normal
	vec3 L; // vec towards light
	vec3 V; // vec toward eye
	vec3 R; // reflected L vec
	vec3 H; // half vec between V & L
	
	
	float NdH;
	float NdV;
	float NdL;
	float VdH;
	
	vec3 f0;
	float alpha;
	
	float metalness;
	float roughness;
	float data;
	vec4 albedo;
};

pointData makePointData(vec3 N, vec3 L, vec3 V, vec3 col, float metal, float rough){
	pointData data;
	
	vec3 h= normalize(L+V);
	vec3 r= reflect(L,N);
	
	data.N= N;
	data.L= L;
	data.V= V;
	data.R= r;
	data.H= h; 
	data.metalness= metal;
	data.roughness= rough;
	data.albedo= vec4(col,1.0);
	data.alpha= rough*rough;
	data.f0=  mix(vec3(.5),col.xyz,vec3(metal));
	
	data.NdH= max(0.0, dot(N,h));
	data.NdV= max(0.0, dot(V,N));
	data.NdL= max(0.0, dot(L,N));
	data.VdH= max(0.0, dot(V,h));
	
	return data;
};


\pbr
#include "pointdata"
uniform bool usePBR;


float walter_GGX(pointData data){
	float a2= data.alpha*data.alpha;
	float f= (data.NdH* data.NdH)*(a2-1.0)+ 1.0;
	return (a2/(PI*f*f));
}

vec3 F_Schlick_vec(pointData data){
	float f= pow(1.0- data.VdH,5.0);
	return data.f0+(vec3(1.0)-data.f0)*f;
}

float GGX(float dotVal,float k){
	return dotVal/(dotVal*(1.0-k)+k);
}

float G_Smith(pointData data){
	float k= pow(data.roughness+1.0,2.0)/8.0;
	return GGX(data.NdL,k)*GGX(data.NdV,k);
}

vec3 specularBRDF(pointData data){
	float D= walter_GGX(data);
	vec3 F= F_Schlick_vec(data);
	float G= G_Smith(data);
	
	vec3 spec= D*G*F;
	spec/= (4.0*data.NdL* data.NdV + 1e-6);
	
	return spec;

}

vec3 getPBRColor(pointData data){
	
	
	vec3 diffCol= (1.0- data.metalness)* data.albedo.xyz;
	vec3 specular= specularBRDF(data);
	vec3 diffuse= diffCol/PI;
	
	return (specular+diffuse);
	
	



}
\reflection
uniform samplerCube u_skybox_texture;
uniform bool u_useReflections;

vec3 calculateReflection(vec3 worldPos, vec3 camPos, vec3 N,float metalness){
	vec3 R= reflect(normalize(worldPos-camPos),N);
	return texture(u_skybox_texture,R,metalness*4).xyz;
}


\commonForwardUniforms

#include "constants"

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

uniform vec3 u_ambient_light;
uniform vec3 u_camera_position;

uniform bool u_use_normalmap;
uniform float u_emissive_factor;
uniform bool u_useOcclusion;

uniform bool u_has_MRT_texture;

//Phong textures:
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_normal_texture;

//Phong Factors:
uniform vec3 u_emmisive_mat_factor;
uniform float u_roughness_mat_factor;
uniform float u_metallic_mat_factor;

const int MAX_LIGHTS= 5;


\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;
in vec4 a_color;

uniform vec3 u_camera_pos;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

uniform float u_time;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_coord;
out vec2 v_uv;

void main()
{	
	v_uv = a_coord;
	gl_Position = vec4( a_vertex, 1.0 );
}

\brightFilter.fs
#version 330 core
in vec2 v_uv;

uniform sampler2D u_texture;
uniform float u_threshold;

out vec4 FragColor;

void main(){
	vec4 col= texture(u_texture,v_uv);
	if(col.x>u_threshold||col.y>u_threshold||col.z>u_threshold){
		FragColor= col;
		return;
	}
	else
		discard;
}


\mix.fs
#version 330 core

in vec2 v_uv;

uniform sampler2D u_texture;
uniform sampler2D u_otherTexture;

out vec4 FragColor;

void main(){
	vec2 uv=v_uv;
	vec3 texture1= texture(u_texture, uv).xyz;
	vec3 texture2= texture(u_otherTexture,uv).xyz;
	vec3 total= texture1+texture2;
	//texture1+=texture2;
	FragColor= vec4(total,1.0);
	
}

\blur.fs
#version 330 core


uniform sampler2D u_texture;
uniform vec2 parameters;
uniform vec2 u_iRes;

out vec4 FragColor;

void main(){  
	
   vec2 texelSize = 1.0 / vec2(textureSize(u_texture, 0));
    vec3 result;
	vec2 uv= gl_FragCoord.xy* u_iRes.xy;
    for (int x = -2; x < 2; ++x) 
    {
        for (int y = -2; y <2 ; ++y) 
        {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            result += texture(u_texture, uv + offset).rgb;
        }
    }
    vec3 blur= result / (4.0 * 4.0);
	
	FragColor=vec4(blur,1.0);
}


\depthOfField.fs
#version 330 core


uniform sampler2D u_depth_texture;
uniform mat4 u_inverse_viewprojection;
uniform sampler2D focusTexture;
uniform sampler2D u_texture;

uniform vec2 focusPoint;
uniform vec2 nearFar;


uniform float u_minDistance;
uniform float u_maxDistance;
uniform float u_alpha_cutoff;

uniform vec2 u_iRes;


out vec4 FragColor;

void main(){
	float far= nearFar.y;
	
	vec2 uv= gl_FragCoord.xy * u_iRes.xy;
	
	float depth= texture(u_depth_texture,uv).x;
	
	vec4 focusColor = texture(focusTexture, uv);
	vec4 outOfFocusColor = texture(u_texture, uv);
	
	FragColor= focusColor;
	
	
	vec4 screen_position= vec4(uv.x*2.0-1.0,uv.y*2.0-1.0,depth*2.0-1.0,1.0); 
	vec4 proj_worldpos= u_inverse_viewprojection* screen_position;
	vec3 worldpos= proj_worldpos.xyz/proj_worldpos.w;

  //if (proj_worldpos.a <= 0) { FragColor = vec4(1.0); return; }
  //if(focusColor.a == 0.0f || outOfFocusColor.a==0.0f )
		//discard;


  vec4 focusPointPos= vec4(focusPoint.x*2.0-1.0,focusPoint.y*2.0-1.0,depth*2.0-1.0,1.0);
  vec4 proj_focuspos= u_inverse_viewprojection* focusPointPos;
  vec3 focuspos= proj_focuspos.xyz/proj_focuspos.w;

  float blur =
    smoothstep
      ( u_minDistance
      , u_maxDistance
      , length(worldpos - focuspos)
      );

	FragColor  = mix(focusColor, outOfFocusColor, blur);
	//FragColor= outOfFocusColor;
	//FragColor= vec4(blur,blur,blur,1.0);   //TODO: fix blur exponent
	//FragColor=outOfFocusColor;


}


\decal.fs
#version 330 core
#include "constants"

in vec2 v_uv;

uniform mat4 u_inverse_viewprojection;
uniform mat4 u_light_shadowmap_vp;
uniform vec2 u_iRes;
uniform vec3 u_camera_position;

uniform mat4 u_model;
uniform mat4 u_imodel;

uniform sampler2D u_depth_texture;
uniform sampler2D u_decal_texture;
uniform sampler2D u_gb0_texture;
uniform sampler2D u_gb1_texture;
uniform sampler2D u_gb2_texture;




out vec4 FragColor;

void main(){

	vec2 uv= gl_FragCoord.xy * u_iRes.xy;
	
	float depth= texture(u_depth_texture,uv).x;
	
	
	vec4 screen_position= vec4(uv.x*2.0-1.0,uv.y*2.0-1.0,depth*2.0-1.0,1.0); 
	
	vec4 proj_worldpos= u_inverse_viewprojection*screen_position;
	vec3 worldPos= proj_worldpos.xyz/proj_worldpos.w;
	
	vec3 localpos= (u_imodel*vec4(worldPos,1.0)).xyz;
	
	if (localpos.x < -1.0 || localpos.x> 1.0 ||
		localpos.y < -1.0 || localpos.y> 1.0 ||
		localpos.z < -1.0 || localpos.z> 1.0) 
		discard;

	//vec4 color= vec4(worldPos.xyz*.01,1.0);
	vec2 decal_uv= localpos.xz*0.5+vec2(0.5);
	vec4 decalColor= texture(u_decal_texture,decal_uv);
	vec4 color= decalColor;
	
	FragColor= color;
}


\volumetric.fs
#version 330 core
#include "constants"

const int MAX_LIGHTS= 5;
uniform mat4 u_inverse_viewprojection;
uniform mat4 u_light_shadowmap_vp;
uniform vec2 u_iRes;
uniform vec3 u_camera_position;
uniform float u_air_density;

uniform sampler2D u_depth_texture;



uniform vec3 u_light_color;
uniform vec3 u_light_vector;
uniform vec3 u_light_position;
uniform float u_light_intensity;


uniform int u_light_type;

uniform int light_index;


uniform float u_spotCosineCuttof;
uniform float u_cone_exp;
uniform float u_shadow_bias;

layout (location=0)out vec4 FragColor;
const int SAMPLES= 64;

#include "shadows"

void main(){
	vec2 uv= gl_FragCoord.xy* u_iRes.xy;
	float depth= texture(u_depth_texture,uv).x;
	vec4 screen_position= vec4(uv.x*2.0-1.0,uv.y*2.0-1.0,depth*2.0-1.0,1.0); 
	
	vec4 proj_worldpos= u_inverse_viewprojection*screen_position;
	vec3 worldPos= proj_worldpos.xyz/proj_worldpos.w;
	
	
	vec3 ray_start = u_camera_position;
	vec3 ray_dir = ( worldPos - ray_start );
	float ray_length = length(ray_dir);
	ray_dir /= ray_length;
	ray_dir = normalize(ray_dir);
	ray_length= min(500.0, ray_length);
	//ray_length = ray_length; //max ray
	
	float step_dist= ray_length/float(SAMPLES);
	
	
	vec3 current_pos= ray_start;
	vec3 ray_offset= ray_dir* step_dist;
	
	//how visible is the point at the end of the ray
	float transparency = 1.0;

	vec3 L;
	if (u_light_type==2)
		L= normalize(u_light_vector);
	else
		L= u_light_position-worldPos;
	float light_dist=length(L);
	
	L/= light_dist;
	
	
	vec3 irradiance= vec3(.0);
	float air_density= u_air_density*.001f;
	
	vec3 color= u_light_color;
	
	//vec3 color= vec3(getShadowAttenuation(worldPos,u_light_shadowmap_vp,u_shadow_bias,shadowAtlasTexture,false,f,light_index,true));
	float in_light= 0;
	
	float spotFactor=1.0;
		if (u_light_type==1){ //Spot
			color/= (u_light_intensity*2);
			vec3 D= u_light_vector;
			float spotCosine= dot(D,L);
			
			if (spotCosine>u_spotCosineCuttof){
				spotFactor= pow(spotCosine,u_cone_exp);
				
			}else{
				spotFactor= 0.0;
			}
		}
	
	for(int i=0;i<SAMPLES; ++i){
	
		//evaluate contribution
		//for every light visible
		
		//compute illumination in this point
		//...
		
		
		float shadow= getShadowAttenuation(current_pos,u_light_shadowmap_vp,u_shadow_bias,shadowAtlasTexture,u_light_type==2,true,light_index,false);
		vec3 light= color*shadow*spotFactor;
		in_light+= shadow;
		
		//vec3 light= u_light_color* (shadow*spotFactor);
		
		//vec3 light =spotFactor*shadow;
		

		//accumulate the amount of light
		irradiance += light * transparency* (air_density* step_dist);
		

		
		
		//...
		
		transparency -= air_density * step_dist;

		//too dense, nothing can be seen behind
		if( transparency < 0.001 )
			break;
		if (distance(current_pos,worldPos)>9000){
			FragColor= vec4(0,0,0,1.0);
			return;
		
	}
		//advance to next position
		current_pos.xyz += ray_offset;

	}

	
	
	//irradiance= vec3(1.0)* (in_light/float(SAMPLES));
	
	FragColor= vec4(irradiance,1.0-transparency);
	//FragColor= vec4(1.0,0,0,1);

}


\irradiance.fs
#version 330 core
#include "constants"


in vec2 v_uv;

uniform mat4 u_inverse_viewprojection;
uniform mat4 u_viewprojection;
uniform vec2 u_iRes;
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_dims;

uniform float u_num_probes;
uniform float u_irr_normal_distance;
uniform float u_irr_delta;

uniform sampler2D u_gb0_texture;
uniform sampler2D u_gb1_texture;
//uniform sampler2D u_gb2_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_SSAO_texture;
uniform sampler2D u_probes_texture;

uniform float multiplier;


layout (location=0)out vec4 FragColor;


#include "sphericalHarmonics"
#include "hdr"




void main(){

	vec2 uv= gl_FragCoord.xy* u_iRes.xy;
	float depth= texture(u_depth_texture,uv).x;
	
	
	vec4 gb0_color= texture(u_gb0_texture,uv); //Albedo
	vec4 gb1_color= texture(u_gb1_texture,uv); //Normal
	vec4 ssao_color= texture(u_SSAO_texture,uv);
	
	
	
	vec3 N= normalize(gb1_color.xyz*2.0- vec3(1.0));
	
	
	
	if (depth>=1.0){
		FragColor= vec4(0,1,0,0.0);
		return;
	}
	
	vec4 screen_position= vec4(uv.x*2.0-1.0,uv.y*2.0-1.0,depth*2.0-1.0,1.0); 
	
	vec4 proj_worldpos= u_inverse_viewprojection*screen_position;
	vec3 worldpos= proj_worldpos.xyz/proj_worldpos.w;
	
	//computing nearest probe index based on world position
	vec3 irr_range = u_irr_end - u_irr_start;
	vec3 irr_local_pos = clamp( worldpos - u_irr_start 	+ N * u_irr_normal_distance, vec3(0.0), irr_range );

	//convert from world pos to grid pos
	vec3 irr_norm_pos = irr_local_pos / u_irr_delta;

	//round values as we cannot fetch between rows for now
	vec3 local_indices = round( irr_norm_pos );

	//compute in which row is the probe stored
	float row = local_indices.x + 	local_indices.y * u_irr_dims.x + 	local_indices.z * u_irr_dims.x * u_irr_dims.y;

	//find the UV.y coord of that row in the probes texture
	float row_uv = (row + 1.0) / (u_num_probes + 1.0);

	SH9Color sh;

	//fill the coefficients
	const float d_uvx = 1.0 / 9.0;
	for(int i = 0; i < 9; ++i)
	{
		vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
		sh.c[i] = texture( u_probes_texture, coeffs_uv).xyz;
	}

	//now we can use the coefficients to compute the irradiance
	vec3 irradiance = ComputeSHIrradiance( N, sh );
	
	vec3 color= gb0_color.xyz *irradiance*ssao_color.xyz*multiplier;
	
	FragColor= vec4(color,1.0);
	
	

}


\probe.fs
#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform mat4 u_viewprojection;
uniform vec3 u_coeffs[9];

out vec4 FragColor;

#include "sphericalHarmonics"

void main(){

	vec3 col= ComputeSHIrradianceVec(normalize(v_normal),u_coeffs);
	FragColor= vec4(col,1.0);
}

\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}

\ssaoFrag.fs
#version 330 core
#include "constants"
const int samples = 64;

in vec2 v_uv;

uniform mat4 u_inverse_viewprojection;
uniform mat4 u_viewprojection;
uniform vec2 u_iRes;
uniform vec3 u_points[samples];

uniform sampler2D u_depth_texture;
uniform sampler2D u_normal_texture;


layout (location=0)out vec4 FragColor;



mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}




void main(){

	vec2 uv= gl_FragCoord.xy* u_iRes.xy;
	float depth= texture(u_depth_texture,uv).x;
	vec3 N= texture(u_normal_texture,uv).xyz;
	N = normalize(N * 2.0 - 1.0);
	
	if (depth>=1.0){
		FragColor= vec4(1.0);
		return;
	}
	
	vec4 screen_position= vec4(uv.x*2.0-1.0,uv.y*2.0-1.0,depth*2.0-1.0,1.0); 
	
	vec4 proj_worldpos= u_inverse_viewprojection*screen_position;
	vec3 worldpos= proj_worldpos.xyz/proj_worldpos.w;
	//lets use 64 samples
	int num = samples; //num samples that passed the are outside
	mat3 rotMat= cotangent_frame(N.xyz,worldpos.xyz,uv);
	//for every sample around the point
	for( int i = 0; i < samples; ++i )
	{
		//compute is world position using the random
		vec3 p = worldpos + (rotMat*u_points[i]) * 10.0;
		
		
		
		
		//find the uv in the depth buffer of this point
		vec4 proj = u_viewprojection * vec4(p,1.0);
		proj.xy /= proj.w; //convert to clipspace from homogeneous
		//apply a tiny bias to its z before converting to clip-space
		proj.z = (proj.z - 0.005) / proj.w;
		proj.xyz = proj.xyz * 0.5 + vec3(0.5); //to [0..1]
		//read p true depth
		float pdepth = texture( u_depth_texture, proj.xy ).x;
		//compare true depth with its depth
		float diff= proj.z-pdepth;
		
		//if( pdepth < proj.z ) //if true depth smaller, is inside
		if( diff>0.0 && diff <.0001)
			num--; //remove this point from the list of visible
	}

	//finally, compute the AO factor as the ratio of visible points
	float ao = float(num) / float(samples);
	FragColor= vec4(ao);
	
	

}

\ssaoblur.fs
#version 330 core

in vec2 v_uv;
uniform sampler2D u_ssao_texture;
uniform vec2 u_iRes;

layout (location=1) out vec4 FragColor;

//https://learnopengl.com/Advanced-Lighting/SSAO
void main(){  
	
   vec2 texelSize = 1.0 / vec2(textureSize(u_ssao_texture, 0));
    float result = 0.0;
	vec2 uv= gl_FragCoord.xy* u_iRes.xy;
    for (int x = -2; x < 2; ++x) 
    {
        for (int y = -2; y <2 ; ++y) 
        {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            result += texture(u_ssao_texture, uv + offset).r;
        }
    }
    float blur=result / (4.0 * 4.0);
	
	FragColor=vec4(blur,blur,blur,1.0);

}

\tonemapping.fs
#version 330 core


in vec2 v_uv;

uniform sampler2D u_texture;
uniform float u_scale; //color scale before tonemapper
uniform float u_average_lum; 
uniform float u_lumwhite2;
uniform float u_igamma; //inverse gamma

layout(location=0) out vec4 FragColor;

#include "hdr"

void main()
{
                   
    
    vec4 color= texture(u_texture, v_uv);
	vec3 rgb= color.xyz;

    float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
	float L = (u_scale / u_average_lum) * lum;
	float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);
	
	rgb= (rgb/lum)*Ld;
	rgb= gamma(max(rgb,vec3(.001)));
	

    FragColor = vec4(rgb, color.w);
} 




\gbuffers.fs 

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;



uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_metallic_roughness_texture;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_normal_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

uniform bool u_use_normalmap;
uniform float u_emissive_factor;
uniform bool u_useOcclusion;

uniform vec3 u_emmisive_mat_factor;
uniform float u_roughness_mat_factor;
uniform float u_metallic_mat_factor;
uniform bool u_has_MRT_texture;



layout (location=0) out vec4 GB0;
layout (location=1) out vec4 GB1;
layout (location=2) out vec4 GB2;
layout (location=3) out vec4 GB3;

#include "normals"
#include "hdr"

void main()
{
	vec3 N;
	vec3 simpleN= normalize(v_normal);
	if(u_use_normalmap){
		vec3 normalUV= texture(u_normal_texture,v_uv).xyz;
		N= perturbNormal(v_normal,v_world_position,v_uv,normalUV);
	}
	else{
		N= simpleN;
		
	}
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );
	vec3 emmisiveCol= texture(u_emissive_texture,v_uv).xyz*u_emissive_factor;
	if (useHDR){
		color.xyz= degamma(color.xyz);
		emmisiveCol= degamma(emmisiveCol.xyz);
	}
	emmisiveCol= emmisiveCol*u_emmisive_mat_factor;
	vec3 MRT_texture;
	if(u_has_MRT_texture){
		MRT_texture= texture(u_metallic_roughness_texture,v_uv).xyz;
		MRT_texture.y*= u_metallic_mat_factor;
		MRT_texture.z*= u_roughness_mat_factor;
	}

	if(color.a < u_alpha_cutoff)
		discard;

	GB0 = vec4(color.xyz,emmisiveCol.x);
	GB1= vec4(N*.5+vec3(0.5),emmisiveCol.y);
	GB2= vec4(u_has_MRT_texture?MRT_texture:vec3(1.0,u_metallic_mat_factor,u_roughness_mat_factor),emmisiveCol.z);
	GB3= vec4(simpleN*.5+vec3(0.5),1.0);
}





\deferred.fs
#version 330 core

#include "constants"
in vec2 v_uv;

const int MAX_LIGHTS= 5;
uniform sampler2D u_gb0_texture;
uniform sampler2D u_gb1_texture;
uniform sampler2D u_gb2_texture;
uniform sampler2D u_gb3_texture;
uniform sampler2D u_depth_texture;

uniform mat4 u_inverse_viewprojection;
uniform vec2 u_iRes;

uniform float u_time;
uniform float u_alpha_cutoff;

uniform vec3 u_ambient_light;
uniform vec3 u_light_color;
uniform vec3 u_light_position;
uniform vec3 u_light_vector;
uniform vec3 u_cone_angle;

uniform vec3 u_camera_position;

uniform float u_light_max_distance;
uniform int u_light_type;
uniform float u_spotCosineCuttof;
uniform bool u_light_cast_shadows;
uniform float u_cone_exp;
uniform mat4 u_light_shadowmap_vp;
uniform float u_shadow_bias;
uniform int light_index;

uniform bool u_inClipSpace;
uniform bool u_useOcclusion;

uniform bool convertToGamma;
//uniform float occlusionFactor;






out vec4 FragColor;

#include "shadows"
#include "normals"
#include "pbr"
#include "ssaoCalc"
#include "hdr"
#include "reflection"

void main(){
	
	float spotFactor=1.0;
	float attFactor=1.0;
	float shadowFactor=1.0;
	float NdotL=1.0;
	vec3 L;
	
	vec2 uv = (u_inClipSpace)?v_uv:gl_FragCoord.xy * u_iRes.xy; 
	vec4 gb0_color= texture(u_gb0_texture,uv); //Albedo  
	vec4 gb1_color= texture(u_gb1_texture,uv); //Normal
	vec4 gb2_color= texture(u_gb2_texture,uv); //MRT
	vec4 gb3_color= texture(u_gb3_texture,uv); //Simple N
	
	float occlusionFactor= gb2_color.x;
	float metallicFactor= gb2_color.y;
	float roughnessFactor= gb2_color.z;
	
	vec3 emmisiveCol= vec3(gb0_color.w,gb1_color.w,gb2_color.w);
	if (useHDR){
		emmisiveCol= degamma(emmisiveCol);
		gb0_color.xyz= degamma(gb0_color.xyz);
	}
	
	float depth= texture(u_depth_texture,uv).x;
	vec4 screen_pos= vec4(uv.x*2.0-1.0,uv.y*2.0-1.0,depth*2.0-1.0,1.0);
	vec4 proj_worldpos= u_inverse_viewprojection*screen_pos;
	vec3 world_position= proj_worldpos.xyz/proj_worldpos.w;
	

	vec3 N= normalize(gb1_color.xyz*2.0-vec3(1.0));
	vec3 N_simple= normalize(gb3_color.xyz*2.0-vec3(1.0));
	vec3 V= normalize(u_camera_position-world_position);
	
	vec4 color= vec4(gb0_color.xyz,1.0);
	
	vec3 light= vec3(u_ambient_light);
	float ambientFactor=getFactor(1.0,uv);
	ambientFactor= pow(ambientFactor,3.0);
	light*=ambientFactor;
	if(u_useOcclusion)
		light*=gb2_color.x;
	
	if (u_light_type==2) //Directional
		L= normalize(u_light_vector);
	else
		L= u_light_position-world_position;
	float light_dist= length(L);
	
	L/= light_dist;
	
	float att_factor= u_light_max_distance-light_dist;
	
	if (u_light_type==1){ //Spot
		vec3 D= u_light_vector;
		float spotCosine= dot(D,L);
		
		if (spotCosine>u_spotCosineCuttof){
			spotFactor= pow(spotCosine,u_cone_exp);
		}else{
			spotFactor= 0.0;
		}
	}
	
	attFactor= (u_light_max_distance-light_dist);
	attFactor/= u_light_max_distance;
	attFactor*=pow(attFactor,2.0);
	attFactor= max(attFactor,0.0);
	
	
	if (u_light_cast_shadows==true)
		shadowFactor= getShadowAttenuation(world_position,u_light_shadowmap_vp,u_shadow_bias,shadowAtlasTexture,u_light_type==2,true,light_index,false);
	
	pointData pData= makePointData(N,L,V,(useHDR?degamma(u_light_color):u_light_color),gb2_color.y,gb2_color.z);
	NdotL= max(dot(L,N),0.0);
	
	float multipliers=(attFactor*spotFactor*shadowFactor);
	if (usePBR)
		light+= getPBRColor(pData)*multipliers;
	else
		light += (NdotL*u_light_color)*attFactor*spotFactor*shadowFactor;
	light+= emmisiveCol;
	color.xyz*= light;
	if (convertToGamma)
		color.xyz= gamma(color.xyz);
	vec3 reflection;
	if(u_useReflections){
		reflection= calculateReflection(world_position, u_camera_position, N_simple,metallicFactor);
		float reflection_factor= (roughnessFactor*(metallicFactor/.6));
		color.xyz= mix(color.xyz,reflection,reflection_factor);
	}
	//color.xyz+=//u_emissive_factor;
	FragColor = color;
	
	//FragColor = vec4(reflection,1.0);
	//FragColor=vec4(metallicFactor,metallicFactor,metallicFactor,1.0);
	//FragColor=vec4(roughnessFactor,roughnessFactor,roughnessFactor,1.0);
	//FragColor= vec4(uv.x,uv.y,0,1.0);
}




\singlePass.fs

#version 330 core

#include "commonForwardUniforms"



uniform vec3 u_light_position[MAX_LIGHTS];
uniform vec3 u_light_color[MAX_LIGHTS];
uniform float u_light_max_distance[MAX_LIGHTS];
uniform int u_light_type[MAX_LIGHTS];
uniform vec3 u_light_vector[MAX_LIGHTS];
uniform float u_cone_angle[MAX_LIGHTS];
uniform float u_cosine_cutoff[MAX_LIGHTS];
uniform float u_cone_exp[MAX_LIGHTS];
uniform int u_cast_shadow[MAX_LIGHTS];
uniform mat4 u_shadow_map_vp[MAX_LIGHTS];
uniform float u_shadowBias[MAX_LIGHTS];
uniform int u_num_lights;

out vec4 FragColor;


#include "shadows"
#include "normals"
#include "pbr"
#include "reflection"







void main()
{
	vec3 N= normalize(v_normal);
	vec3 N_simple= N;
	vec2 uv = v_uv;
	vec4 color = u_color;
	vec3 V= normalize(u_camera_position-v_world_position);
	
	color *= texture( u_texture, v_uv );
	
	if(color.a < u_alpha_cutoff)
		discard;
		
	
	
	float occlusionFactor= u_has_MRT_texture?texture(u_metallic_roughness_texture,v_uv).x:1.0;
	float metallicFactor= u_has_MRT_texture?texture(u_metallic_roughness_texture,v_uv).y*u_metallic_mat_factor:u_metallic_mat_factor;
	float roughnessFactor=u_has_MRT_texture?texture(u_metallic_roughness_texture,v_uv).z*u_roughness_mat_factor:u_roughness_mat_factor;
	
	vec4 emissive= texture(u_emissive_texture,v_uv);
	emissive.xyz*=u_emmisive_mat_factor;
	
	if(u_use_normalmap){
		vec3 normalUV= texture(u_normal_texture,v_uv).xyz;
		N= perturbNormal(v_normal,v_world_position,v_uv,normalUV);
	}
	vec3 light= vec3(u_ambient_light);
	if(u_useOcclusion)
		light*=occlusionFactor;
	
	
	for( int i = 0; i < MAX_LIGHTS; ++i )
	{
		if(i < u_num_lights)
		{
			
			vec3 L;
			float lightDist=1.0;
			float attFactor=1.0;
			float spotFactor= 1.0;
			float shadowFactor= 1.0;
			float NdotL= 1.0;
			
			if (u_light_type[i]==2){ //Directional
				L= normalize(u_light_vector[i]);
				
			}else{
				L= vec3(u_light_position[i]-v_world_position);
				lightDist= length(L);
				L/=lightDist;
				
				
				if (u_light_type[i]==1){ //Spot
					vec3 D= vec3(u_light_vector[i]);
					float spotCosine= dot(D,L);
					
					if (spotCosine> u_cosine_cutoff[i]){
						spotFactor= pow(spotCosine,u_cone_exp[i]);
					}else{
						spotFactor= 0.0;
					}
				}
				
				attFactor= (u_light_max_distance[i]-lightDist);
				attFactor/= u_light_max_distance[i];
				attFactor*= pow (attFactor,2.0);
				attFactor= max(attFactor,0.0);		
			}
			
			if (u_cast_shadow[i]==1)
				shadowFactor= getShadowAttenuation(v_world_position,u_shadow_map_vp[i], u_shadowBias[i], shadowAtlasTexture,u_light_type[i]==2,true,i,false);
			
			
					
			pointData pData= makePointData(N,L,V,u_light_color[i],metallicFactor,roughnessFactor);
			NdotL= max(dot(L,N),0.0);
			
			
			float multipliers=(attFactor*spotFactor*shadowFactor);
			if (usePBR)
				light+= getPBRColor(pData)*multipliers;
			else
				light+= (NdotL*u_light_color[i])*multipliers;
			
		}
		
	}
	color.xyz*= light;
	
	color.xyz+=emissive.xyz*u_emissive_factor;
	
	if(u_useReflections){
		vec3 reflection= calculateReflection(v_world_position, u_camera_position, N_simple,metallicFactor);
		float reflection_factor= (roughnessFactor*(metallicFactor/.6));
		color.xyz= mix(color.xyz,reflection,reflection_factor);
	}
	FragColor = color;
	//FragColor=vec4(metallicFactor,metallicFactor,metallicFactor,1.0);
	//FragColor=vec4(roughnessFactor,roughnessFactor,roughnessFactor,1.0);
	//FragColor=vec4((roughnessFactor*(metallicFactor/.5))*.8,(roughnessFactor*(metallicFactor/.5))*.8,(roughnessFactor*(metallicFactor/.5))*.8,1.0);
	//FragColor= emissive;
}

\multiPass.fs
#version 330 core
#include "commonForwardUniforms"




uniform float u_light_max_distance;

uniform vec3 u_light_position;
uniform vec3 u_light_color;
uniform int  u_light_type;
uniform vec3 u_light_vector;


uniform vec3 u_target_pos;
uniform float u_spotCosineCuttof;
uniform float u_cone_exp;
uniform float u_cone_angle;


uniform bool u_light_cast_shadows;
uniform sampler2D u_light_shadowmap;
uniform mat4 u_light_shadowmap_vp;
uniform float u_shadow_bias;

uniform int light_index;


out vec4 FragColor;

#include "shadows"
#include "normals"
#include "pbr"
#include "reflection"

void main()
{
	vec3 N= normalize(v_normal);
	vec3 N_simple= N;
	vec2 uv = v_uv;
	vec4 color = u_color;
	vec3 L;
	vec3 V= normalize(u_camera_position-v_world_position);
	color *= texture( u_texture, v_uv );
	if(color.a < u_alpha_cutoff)
		discard;

	float lightDist=1.0;
	float attFactor= 1.0;
	float spotFactor=1.0;
	float shadowFactor= 1.0;
	
	float NdotL=1.0;
	
	float occlusionFactor= texture(u_metallic_roughness_texture,v_uv).x;
	float metallicFactor= texture(u_metallic_roughness_texture,v_uv).y*u_metallic_mat_factor;
	float roughnessFactor= texture(u_metallic_roughness_texture,v_uv).z*u_roughness_mat_factor;
	vec4 emissive= texture(u_emissive_texture,v_uv);
	emissive.xyz= emissive.xyz*u_emmisive_mat_factor;
	
	if(u_use_normalmap){
		vec3 normalUV= texture(u_normal_texture,v_uv).xyz;
		N= perturbNormal(v_normal,v_world_position,v_uv,normalUV);
	}
	vec3 light=u_ambient_light;
	if(u_useOcclusion)
		light*=occlusionFactor;
	
	if (u_light_type==2){ //Directional Light
		L= normalize(u_light_vector);
		
	}
	else{
		L= (u_light_position-v_world_position);
		lightDist= length(L);
		L/=lightDist;
		if (u_light_type==1){ //Spot
			vec3 D= u_light_vector;
			float spotCosine= dot(D,L);
			
			if (spotCosine>u_spotCosineCuttof){
				spotFactor= pow(spotCosine,u_cone_exp);
			}else{
				spotFactor= 0.0;
			}
		}
		attFactor= (u_light_max_distance-lightDist);
		attFactor/= u_light_max_distance;
		attFactor*=pow(attFactor,2.0);
		attFactor= max(attFactor,0.0);
	}
	
	if (u_light_cast_shadows==true)
		shadowFactor= getShadowAttenuation(v_world_position,u_light_shadowmap_vp,u_shadow_bias,shadowAtlasTexture,u_light_type==2,true,light_index,false);
	
	NdotL= max(dot(L,N),0.0);
	
	pointData pData= makePointData(N,L,V,u_light_color,metallicFactor,roughnessFactor);
	
	float multipliers= attFactor*spotFactor*shadowFactor;
	if (usePBR)
		light+= getPBRColor(pData)*multipliers;
	else
		light += (NdotL*u_light_color)*attFactor*spotFactor*shadowFactor;
	
	color.xyz*= light;
	if(light_index==0 && u_useReflections){
		color.xyz+=emissive.xyz*u_emissive_factor;
		vec3 reflection= calculateReflection(v_world_position, u_camera_position, N_simple,metallicFactor);
		float reflection_factor= (roughnessFactor*(metallicFactor/.6));
		color.xyz= mix(color.xyz,reflection,reflection_factor);
	}
	FragColor = color;
}

\noLights.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;
uniform vec3 u_ambient_light;

out vec4 FragColor;


void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	color.xyz*= u_ambient_light;
	FragColor = color;
}

\skybox.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position; 
uniform vec3 u_camera_position;
uniform samplerCube u_texture;
out vec4 FragColor;

void main()
{
	vec3 V= v_world_position - u_camera_position;

	FragColor = texture(u_texture,V);
}

\reflectionProbe.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position; 
in vec3 v_normal;
uniform vec3 u_camera_position;
uniform samplerCube u_texture;
out vec4 FragColor;

void main()
{
	vec3 V= v_world_position - u_camera_position;
	vec3 N= normalize(v_normal);
	vec3 R= reflect(V,N);
	FragColor = textureLod(u_texture,R,5);
}

\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

out vec4 FragColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, v_uv );

	if(color.a < u_alpha_cutoff)
		discard;

	FragColor = color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv );

	if(color.a < u_alpha_cutoff)
		discard;

	vec3 N = normalize(v_normal);

	FragColor = color;
	NormalColor = vec4(N,1.0);
}

\flat.fs

#version 330 core

out vec4 FragColor;

void main(){
FragColor=vec4(1.0,1.0,1.0,1.0);
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	if( n == 0.0 && f == 1.0 )
		FragColor = vec4(z);
	else
		FragColor = vec4( n * (z + 1.0) / (f + n - z * (f - n)) );
}


\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_coord;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_coord;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}